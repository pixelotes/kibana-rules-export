#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

root_command() {
  #!/usr/bin/env bash

  KIBANA_URL=${args[--url]:-"https://localhost:5601"}
  USERNAME=${args[--username]:-"elastic"}
  PASSWORD=${args[--password]:-"changeme"}
  FORMAT=${args[--format]:-"csv"}
  FILTER=${args[--query]:-"alert.attributes.enabled:true"}
  PAGE_SIZE=${args[--page_size]:-"1000"}
  SKIP_TLS=${args[--insecure]}
  # Load requested columns or use default set
  if [[ -n "${args[--column]}" ]]; then
    eval "COLUMNS=(${args[--column]})"
  else
    COLUMNS=(name description tags query)
  fi

  # Fetch rules from Kibana
  curl_flags=(-sSL --fail)
  [[ -n "$SKIP_TLS" ]] && curl_flags+=(--insecure)

  if response=$(curl "${curl_flags[@]}" \
      -u "$USERNAME:$PASSWORD" \
      -H "kbn-xsrf: true" \
      "$KIBANA_URL/api/detection_engine/rules/_find?filter=$FILTER&per_page=$PAGE_SIZE" 2>&1); then

    echo "🔍 Fetched $(echo "$response" | jq '.data | length') rules."
  else
    echo "❌ Failed to fetch rules from Kibana:"
    echo "$response"
    exit 1
  fi

  # Get available keys from the first rule
  AVAILABLE=($(echo "$response" | jq -r '.data[0] | keys[]'))

  for col in "${COLUMNS[@]}"; do
    if ! [[ " ${AVAILABLE[*]} " == *" $col "* ]]; then
      echo "❌ Invalid column: $col"
      echo "Valid options: ${AVAILABLE[*]}"
      exit 1
    fi
  done

  # Set output
  if [[ "$FORMAT" == "csv" ]]; then
    OUTPUT="rules.csv"
  elif [[ "$FORMAT" == "markdown" ]]; then
    OUTPUT="rules.md"
  else
    OUTPUT="rules.json"
  fi

  # Generate headers dynamically from the specified columns
  header=""
  for col in "${COLUMNS[@]}"; do
    header+="${col^},"    # capitalize header
  done
  header=${header%,}      # trim trailing comma

  if [[ "$FORMAT" == "csv" ]]; then
    echo "$header" > "$OUTPUT"
  elif [[ "$FORMAT" == "markdown" ]]; then
    formatted="| ${header//,/ | } |"

    # Generate the markdown separator line
    separator="|"
    for _ in "${COLUMNS[@]}"; do
      separator+=" --- |"
    done

    {
      echo "$formatted"
      echo "$separator"
    } > "$OUTPUT"
  fi

  # Parse and export
  echo "🔧 Processing the response..."
  if [ "$FORMAT" == "json" ]; then
      echo "$response" | jq > "$OUTPUT"
  else
    echo "$response" | jq -c '.data[]' | while read -r obj; do
    row=()
    for col in "${COLUMNS[@]}"; do
      val=$(echo "$obj" | jq -r --arg c "$col" '
        if $c=="tags" then (.tags | join(", "))
        else .[$c]
        end' | tr '\n' ' ' | sed 's/|/\\|/g')

      if [[ "$FORMAT" == "csv" ]]; then
        val="${val//\"/\"\"}"
        joined="\"$val\""
        val=$joined
      fi
      row+=("$val")
    done

    if [[ "$FORMAT" == "csv" ]]; then
      out="$(IFS=,; echo "${row[*]}")"
      echo "$out" >> "$OUTPUT"
    else
      printf "|%s|\n" "$(IFS='|'; echo "${row[*]}")" >> "$OUTPUT"
    fi

    done

  fi

  echo "✅ Done! Output saved to $OUTPUT"

}

version_command() {
  echo "$version"
}

kibana_rules_export_usage() {
  printf "kibana-rules-export - Command-line tool to export enabled detection rules from Kibana to JSON, CSV or Markdown format using the Detection Engine API from Kibana. Its aim is to help documenting the active Kibana security rules. By default, it only returns the enabled rules, but the filter can be customized.\n\n"

  printf "%s\n" "Usage:"
  printf "  kibana-rules-export [OPTIONS]\n"
  printf "  kibana-rules-export --help | -h\n"
  printf "  kibana-rules-export --version | -v\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--username, -u USERNAME (required)"
    printf "    Kibana username\n"
    echo

    printf "  %s\n" "--password, -p PASSWORD (required)"
    printf "    Kibana password\n"
    echo

    printf "  %s\n" "--url URL"
    printf "    Kibana base URL\n"
    printf "    %s\n" "Default: http://localhost:5601"
    echo

    printf "  %s\n" "--query, -q FILTER"
    printf "    Query filter. Default is enabled alerts.\n"
    printf "    %s\n" "Default: alert.attributes.enabled:true"
    echo

    printf "  %s\n" "--page_size PAGE_SIZE"
    printf "    Number of results returned per page\n"
    printf "    %s\n" "Default: 1000"
    echo

    printf "  %s\n" "--column, -c COLUMN (repeatable)"
    printf "    Specify output columns (e.g. name,description,severity). Can be used\n    multiple times\n"
    echo

    printf "  %s\n" "--format, -f FORMAT"
    printf "    Output format (csv, markdown or json)\n"
    printf "    %s\n" "Allowed: csv, markdown, json"
    printf "    %s\n" "Default: csv"
    echo

    printf "  %s\n" "--insecure, -i"
    printf "    Skip SSL certificate verification\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        kibana_rules_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  if ! command -v bash >/dev/null 2>&1; then
    printf "missing dependency: bash\n" >&2
    missing_deps=1
  else
    deps['bash']="$(command -v bash | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="root"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --username | -u)

        if [[ -n ${2+x} ]]; then
          args['--username']="$2"
          shift
          shift
        else
          printf "%s\n" "--username requires an argument: --username, -u USERNAME" >&2
          exit 1
        fi
        ;;

      --password | -p)

        if [[ -n ${2+x} ]]; then
          args['--password']="$2"
          shift
          shift
        else
          printf "%s\n" "--password requires an argument: --password, -p PASSWORD" >&2
          exit 1
        fi
        ;;

      --url)

        if [[ -n ${2+x} ]]; then
          args['--url']="$2"
          shift
          shift
        else
          printf "%s\n" "--url requires an argument: --url URL" >&2
          exit 1
        fi
        ;;

      --query | -q)

        if [[ -n ${2+x} ]]; then
          args['--query']="$2"
          shift
          shift
        else
          printf "%s\n" "--query requires an argument: --query, -q FILTER" >&2
          exit 1
        fi
        ;;

      --page_size)

        if [[ -n ${2+x} ]]; then
          args['--page_size']="$2"
          shift
          shift
        else
          printf "%s\n" "--page_size requires an argument: --page_size PAGE_SIZE" >&2
          exit 1
        fi
        ;;

      --column | -c)

        if [[ -n ${2+x} ]]; then
          escaped="$(printf '%q' "$2")"
          if [[ -z ${args['--column']+x} ]]; then
            args['--column']="$escaped"
          else
            args['--column']="${args['--column']} $escaped"
          fi
          shift
          shift
        else
          printf "%s\n" "--column requires an argument: --column, -c COLUMN" >&2
          exit 1
        fi
        ;;

      --format | -f)

        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      --insecure | -i)

        args['--insecure']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--username']+x} ]]; then
    printf "missing required flag: --username, -u USERNAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--password']+x} ]]; then
    printf "missing required flag: --password, -p PASSWORD\n" >&2
    exit 1
  fi

  [[ -n ${args['--url']:-} ]] || args['--url']="http://localhost:5601"
  [[ -n ${args['--query']:-} ]] || args['--query']="alert.attributes.enabled:true"
  [[ -n ${args['--page_size']:-} ]] || args['--page_size']="1000"
  [[ -n ${args['--format']:-} ]] || args['--format']="csv"

  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(csv|markdown|json)$ ]]; then
    printf "%s\n" "--format must be one of: csv, markdown, json" >&2
    exit 1
  fi

}

initialize() {
  declare -g version="1.0"
  set -e

}

run() {

  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

initialize
run "$@"
