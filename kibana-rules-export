#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

root_command() {
  #!/usr/bin/env bash

  KIBANA_URL=${args[--url]:-"https://localhost:5601"}
  USERNAME=${args[--username]:-"elastic"}
  PASSWORD=${args[--password]:-"changeme"}
  FORMAT=${args[--format]:-"csv"}
  PAGE_SIZE=${args[--page_size]:-"1000"}
  SKIP_TLS=${args[--insecure]}

  # Output file based on format
  if [[ "$FORMAT" == "csv" ]]; then
    OUTPUT="rules.csv"
    echo "\"Name\",\"Description\",\"Tags\",\"Query\"" > "$OUTPUT"
  elif [ "$FORMAT" == "json" ]; then
    OUTPUT="rules.json"
  else
    OUTPUT="rules.md"
    {
      echo "| Name | Description | Tags | Query |"
      echo "|------|-------------|------|-------|"
    } > "$OUTPUT"
  fi

  # Fetch rules from Kibana
  echo "📡 Fetching enabled rules from $KIBANA_URL ..."

  if [[ "$SKIP_TLS" == "1" ]] || [[ -n "$SKIP_TLS" ]]; then
    # Add --insecure flag to curl commands
    response=$(curl -s -k -u "$USERNAME:$PASSWORD" \
    -H "kbn-xsrf: true" \
    --insecure \
    "$KIBANA_URL/api/detection_engine/rules/_find?filter=alert.attributes.enabled:true&per_page=$PAGE_SIZE")
  else
    response=$(curl -s -k -u "$USERNAME:$PASSWORD" \
    -H "kbn-xsrf: true" \
    "$KIBANA_URL/api/detection_engine/rules/_find?filter=alert.attributes.enabled:true&per_page=$PAGE_SIZE")
  fi

  # Exit if the response doesn't contain data
  if ! echo "$response" | jq -e '.data' > /dev/null 2>&1; then
      echo "❌ Failed to fetch rules from Kibana or invalid response format"
      echo "Response: $response"
      exit 1
  else
      LINES=$(echo "$response" | jq | wc -l)
      echo "🔍 The response format looks correct and contains $LINES lines"
  fi

  # Parse and export
  echo "🔧 Processing the response..."
  if [ "$FORMAT" == "json" ]; then
      echo "$response" | jq > "$OUTPUT"
  else
    echo "$response" | jq -r '
      .data[]
      | [
          .name,
          .description,
          (.tags | join(", ")),
          .query
        ]
      | @tsv
    ' | while IFS=$'\t' read -r name desc tags query; do
      name="${name//|/\\|}"
      desc=$(echo "$desc" | tr '\n' ' ' | sed 's/|/\\|/g')
      tags="${tags//|/\\|}"
      query=$(echo "$query" | tr '\n' ' ' | sed 's/|/\\|/g')

      [[ ${#query} -gt 200 ]] && query="${query:0:200}…"

      if [[ "$FORMAT" == "csv" ]]; then
        #name=$(echo "$name" | sed 's/"/""/g')
        #desc=$(echo "$desc" | sed 's/"/""/g')
        #tags=$(echo "$tags" | sed 's/"/""/g')
        #query=$(echo "$query" | sed 's/"/""/g')
        name=${name//\"/\"\"}
        desc=${desc//\"/\"\"}
        tags=${tags//\"/\"\"}
        query=${query//\"/\"\"}
        echo "\"$name\",\"$desc\",\"$tags\",\"$query\"" >> "$OUTPUT"
      else
        echo "| $name | $desc | $tags | \`$query\` |" >> "$OUTPUT"
      fi
    done
  fi

  echo "✅ Done! Output saved to $OUTPUT"

}

version_command() {
  echo "$version"
}

kibana_rules_export_usage() {
  printf "kibana-rules-export - Export enabled detection rules from Kibana to CSV or Markdown\n\n"

  printf "%s\n" "Usage:"
  printf "  kibana-rules-export [OPTIONS]\n"
  printf "  kibana-rules-export --help | -h\n"
  printf "  kibana-rules-export --version | -v\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--username USERNAME (required)"
    printf "    Kibana username\n"
    echo

    printf "  %s\n" "--password PASSWORD (required)"
    printf "    Kibana password\n"
    echo

    printf "  %s\n" "--url URL"
    printf "    Kibana base URL\n"
    printf "    %s\n" "Default: http://localhost:5601"
    echo

    printf "  %s\n" "--page_size PAGE_SIZE"
    printf "    Number of results returned per page\n"
    printf "    %s\n" "Default: 1000"
    echo

    printf "  %s\n" "--format FORMAT"
    printf "    Output format (csv, markdown or json)\n"
    printf "    %s\n" "Allowed: csv, markdown, json"
    printf "    %s\n" "Default: csv"
    echo

    printf "  %s\n" "--insecure"
    printf "    Skip SSL certificate verification\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        kibana_rules_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  missing_deps=

  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  action="root"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --username)

        if [[ -n ${2+x} ]]; then
          args['--username']="$2"
          shift
          shift
        else
          printf "%s\n" "--username requires an argument: --username USERNAME" >&2
          exit 1
        fi
        ;;

      --password)

        if [[ -n ${2+x} ]]; then
          args['--password']="$2"
          shift
          shift
        else
          printf "%s\n" "--password requires an argument: --password PASSWORD" >&2
          exit 1
        fi
        ;;

      --url)

        if [[ -n ${2+x} ]]; then
          args['--url']="$2"
          shift
          shift
        else
          printf "%s\n" "--url requires an argument: --url URL" >&2
          exit 1
        fi
        ;;

      --page_size)

        if [[ -n ${2+x} ]]; then
          args['--page_size']="$2"
          shift
          shift
        else
          printf "%s\n" "--page_size requires an argument: --page_size PAGE_SIZE" >&2
          exit 1
        fi
        ;;

      --format)

        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format FORMAT" >&2
          exit 1
        fi
        ;;

      --insecure)

        args['--insecure']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  if [[ -z ${args['--username']+x} ]]; then
    printf "missing required flag: --username USERNAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--password']+x} ]]; then
    printf "missing required flag: --password PASSWORD\n" >&2
    exit 1
  fi

  [[ -n ${args['--url']:-} ]] || args['--url']="http://localhost:5601"
  [[ -n ${args['--page_size']:-} ]] || args['--page_size']="1000"
  [[ -n ${args['--format']:-} ]] || args['--format']="csv"

  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(csv|markdown|json)$ ]]; then
    printf "%s\n" "--format must be one of: csv, markdown, json" >&2
    exit 1
  fi

}

initialize() {
  declare -g version="1.0"
  set -e

}

run() {

  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

initialize
run "$@"
