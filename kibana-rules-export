#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  #!/usr/bin/env bash

  KIBANA_URL=${args[--url]:-"https://localhost:5601"}
  USERNAME=${args[--username]:-"elastic"}
  PASSWORD=${args[--password]:-"changeme"}
  FORMAT=${args[--format]:-"csv"}
  PAGE_SIZE=${args[--page_size]:-"1000"}
  SKIP_TLS=${args[--insecure]}

  # Output file based on format
  if [[ "$FORMAT" == "csv" ]]; then
    OUTPUT="rules.csv"
    echo "\"Name\",\"Description\",\"Tags\",\"Query\"" > "$OUTPUT"
  elif [ "$FORMAT" == "json" ]; then
    OUTPUT="rules.json"
  else
    OUTPUT="rules.md"
    {
      echo "| Name | Description | Tags | Query |"
      echo "|------|-------------|------|-------|"
    } > "$OUTPUT"
  fi

  # Fetch rules from Kibana
  echo "ðŸ“¡ Fetching enabled rules from $KIBANA_URL ..."

  if [[ "$SKIP_TLS" == "1" ]] || [[ -n "$SKIP_TLS" ]]; then
    # Add --insecure flag to curl commands
    response=$(curl -s -k -u "$USERNAME:$PASSWORD" \
    -H "kbn-xsrf: true" \
    --insecure \
    "$KIBANA_URL/api/detection_engine/rules/_find?filter=alert.attributes.enabled:true&per_page=$PAGE_SIZE")
  else
    response=$(curl -s -k -u "$USERNAME:$PASSWORD" \
    -H "kbn-xsrf: true" \
    "$KIBANA_URL/api/detection_engine/rules/_find?filter=alert.attributes.enabled:true&per_page=$PAGE_SIZE")
  fi

  # Exit if the response doesn't contain data
  if ! echo "$response" | jq -e '.data' > /dev/null 2>&1; then
      echo "âŒ Failed to fetch rules from Kibana or invalid response format"
      echo "Response: $response"
      exit 1
  else
      LINES=$(echo $response | jq | wc -l)
      echo "ðŸ” The response format looks correct and contains $LINES lines"
  fi

  # Parse and export
  echo "ðŸ”§ Processing the response..."
  if [ "$FORMAT" == "json" ]; then
      echo $response | jq > "$OUTPUT"
  else
    echo "$response" | jq -r '
      .data[]
      | [
          .name,
          .description,
          (.tags | join(", ")),
          .query
        ]
      | @tsv
    ' | while IFS=$'\t' read -r name desc tags query; do
      name="${name//|/\\|}"
      desc=$(echo "$desc" | tr '\n' ' ' | sed 's/|/\\|/g')
      tags="${tags//|/\\|}"
      query=$(echo "$query" | tr '\n' ' ' | sed 's/|/\\|/g')

      [[ ${#query} -gt 200 ]] && query="${query:0:200}â€¦"

      if [[ "$FORMAT" == "csv" ]]; then
        name=$(echo "$name" | sed 's/"/""/g')
        desc=$(echo "$desc" | sed 's/"/""/g')
        tags=$(echo "$tags" | sed 's/"/""/g')
        query=$(echo "$query" | sed 's/"/""/g')
        echo "\"$name\",\"$desc\",\"$tags\",\"$query\"" >> "$OUTPUT"
      else
        echo "| $name | $desc | $tags | \`$query\` |" >> "$OUTPUT"
      fi
    done
  fi

  echo "âœ… Done! Output saved to $OUTPUT"

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
kibana_rules_export_usage() {
  printf "kibana-rules-export - Export enabled detection rules from Kibana to CSV or Markdown\n\n"

  printf "%s\n" "Usage:"
  printf "  kibana-rules-export [OPTIONS]\n"
  printf "  kibana-rules-export --help | -h\n"
  printf "  kibana-rules-export --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--username USERNAME (required)"
    printf "    Kibana username\n"
    echo

    # :flag.usage
    printf "  %s\n" "--password PASSWORD (required)"
    printf "    Kibana password\n"
    echo

    # :flag.usage
    printf "  %s\n" "--url URL"
    printf "    Kibana base URL\n"
    printf "    %s\n" "Default: http://localhost:5601"
    echo

    # :flag.usage
    printf "  %s\n" "--page_size PAGE_SIZE"
    printf "    Number of results returned per page\n"
    printf "    %s\n" "Default: 1000"
    echo

    # :flag.usage
    printf "  %s\n" "--format FORMAT"
    printf "    Output format (csv, markdown or json)\n"
    printf "    %s\n" "Allowed: csv, markdown, json"
    printf "    %s\n" "Default: csv"
    echo

    # :flag.usage
    printf "  %s\n" "--insecure"
    printf "    Skip SSL certificate verification\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        kibana_rules_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  # :dependency.filter
  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --username)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--username']="$2"
          shift
          shift
        else
          printf "%s\n" "--username requires an argument: --username USERNAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --password)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--password']="$2"
          shift
          shift
        else
          printf "%s\n" "--password requires an argument: --password PASSWORD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --url)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--url']="$2"
          shift
          shift
        else
          printf "%s\n" "--url requires an argument: --url URL" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --page_size)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--page_size']="$2"
          shift
          shift
        else
          printf "%s\n" "--page_size requires an argument: --page_size PAGE_SIZE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --format)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --insecure)

        # :flag.case_no_arg
        args['--insecure']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--username']+x} ]]; then
    printf "missing required flag: --username USERNAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--password']+x} ]]; then
    printf "missing required flag: --password PASSWORD\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--url']:-} ]] || args['--url']="http://localhost:5601"
  [[ -n ${args['--page_size']:-} ]] || args['--page_size']="1000"
  [[ -n ${args['--format']:-} ]] || args['--format']="csv"

  # :command.whitelist_filter
  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(csv|markdown|json)$ ]]; then
    printf "%s\n" "--format must be one of: csv, markdown, json" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
